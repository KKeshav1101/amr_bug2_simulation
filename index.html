<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bug2 AMR Simulation</title>
  <style>
    body {
      background-color: #0b0e17;
      color: #eee;
      font-family: 'Poppins', sans-serif;
      margin: 0;
      display: flex;
      flex-direction: row;
      height: 100vh;
      overflow: hidden;
    }
    #leftPanel {
      flex: 2;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #rightPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 20px;
    }
    #topControls, #midControls, #bottomLog {
      background: #1f2937;
      border-radius: 12px;
      box-shadow: 0 0 15px #00ffff33;
      padding: 15px;
      margin-bottom: 15px;
    }
    #topControls {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-around;
    }
    #midControls {
      text-align: center;
    }
    #bottomLog {
      flex-grow: 1;
      overflow-y: auto;
    }
    button, input[type=range] {
      background: #00bcd4;
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 15px;
      padding: 8px 15px;
      cursor: pointer;
      margin: 5px;
    }
    input[type=range] {
      width: 120px;
      accent-color: #00ffff;
    }
    canvas {
      background-color: #111827;
      border: 2px solid #00ffff44;
      border-radius: 10px;
      box-shadow: 0 0 10px #00ffff33;
    }
  </style>
</head>
<body>
  <div id="leftPanel">
    <canvas id="simCanvas" width="600" height="400"></canvas>
  </div>
  <div id="rightPanel">
    <div id="topControls">
      <button id="initBtn">Initiate</button>
      <button id="resetBtn">Reset</button>
      <button id="addObsBtn">Add Obstacle</button>
      <button id="removeObsBtn">Remove Obstacle</button>
    </div>
    <div id="midControls">
      <label>Speed:</label>
      <input type="range" id="speedSlider" min="0.3" max="3" step="0.1" value="1.0" /><br>
      <label>Sensor FOV:</label>
      <input type="range" id="fovSlider" min="20" max="120" step="5" value="60" />
    </div>
    <div id="bottomLog">
      <div id="log" style="font-size:13px; color:#cbd5e1;"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const logDiv = document.getElementById('log');
    const speedSlider = document.getElementById('speedSlider');
    const fovSlider = document.getElementById('fovSlider');

    const robot = {
      x: 100,
      y: 300,
      r: 10,
      heading: 0,
      speed: 1.0,
      mode: 'goto',
      stuckFrames: 0,
      prevPos: {x: 0, y: 0},
      fov: 60
    };

    let start = null, goal = null;
    let obstacles = [ {x: 220, y: 150, w: 160, h: 100} ];

    function log(msg) {
      logDiv.innerHTML += msg + '<br>';
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    speedSlider.addEventListener('input', () => {
      robot.speed = parseFloat(speedSlider.value);
    });

    fovSlider.addEventListener('input', () => {
      robot.fov = parseFloat(fovSlider.value);
      log('Sensor FOV adjusted to ' + robot.fov + '°');
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (!start) {
        start = {x, y};
        log('Start selected.');
      } else if (!goal) {
        goal = {x, y};
        log('Goal selected.');
      }
    });

    document.getElementById('initBtn').onclick = () => {
      if (start && goal) {
        robot.x = start.x;
        robot.y = start.y;
        robot.heading = Math.atan2(goal.y - start.y, goal.x - start.x);
        log('Initiated Bug2 navigation.');
        requestAnimationFrame(update);
      }
    };

    document.getElementById('resetBtn').onclick = () => {
      start = null; goal = null;
      robot.x = 100; robot.y = 300; robot.mode = 'goto';
      logDiv.innerHTML = '';
      draw();
    };

    document.getElementById('addObsBtn').onclick = () => {
      const newObs = {x: Math.random()*500, y: Math.random()*300, w: 50+Math.random()*50, h: 50+Math.random()*50};
      obstacles.push(newObs);
      log('Added obstacle. Total: ' + obstacles.length);
      draw();
    };

    document.getElementById('removeObsBtn').onclick = () => {
      obstacles.pop();
      log('Removed obstacle. Total: ' + obstacles.length);
      draw();
    };

    function sense() {
      const halfFov = (robot.fov * Math.PI / 180) / 2;
      const dirs = [-halfFov, 0, halfFov, Math.PI];
      return dirs.map(d => distanceToObstacle(robot.x, robot.y, robot.heading + d));
    }

    function distanceToObstacle(x, y, angle) {
      const maxDist = 60;
      for (let d = 0; d < maxDist; d += 2) {
        const px = x + Math.cos(angle) * d;
        const py = y + Math.sin(angle) * d;
        for (let obs of obstacles) {
          if (px > obs.x && px < obs.x + obs.w && py > obs.y && py < obs.y + obs.h) {
            return d;
          }
        }
      }
      return maxDist;
    }

    function update() {
      const [left, front, right] = sense();

      const dx = robot.x - robot.prevPos.x;
      const dy = robot.y - robot.prevPos.y;
      const moved = Math.hypot(dx, dy);
      robot.prevPos = {x: robot.x, y: robot.y};

      if (moved < 0.5) robot.stuckFrames++; else robot.stuckFrames = 0;

      if (robot.mode === 'goto') {
        if (front < 15) {
          robot.mode = 'wall-follow';
          log('Obstacle hit. Switching to wall-follow mode.');
        } else {
          moveTowards(goal);
        }
      } else if (robot.mode === 'wall-follow') {
        if (isOnMLine() && front > 30) {
          robot.mode = 'goto';
          log('Rejoining M-line. Switching to go-to-goal.');
        } else if (robot.stuckFrames > 25) {
          robot.mode = 'escape';
          log('Corner detected. Escaping corner.');
        } else {
          followWall(left, front, right);
          if (front > 25 && Math.abs(angleToGoal()) < 0.3 && isOnMLine()) {
            robot.mode = 'goto';
            log('Rejoined M-line after wall-follow.');
          }
        }
      } else if (robot.mode === 'escape') {
        escapeCorner();
      }

      draw();
      if (goal && Math.hypot(goal.x - robot.x, goal.y - robot.y) > 10) {
        requestAnimationFrame(update);
      } else {
        log('Goal reached ✅');
      }
    }

    function moveTowards(target) {
      const desired = Math.atan2(target.y - robot.y, target.x - robot.x);
      robot.heading = desired;
      robot.x += Math.cos(robot.heading) * robot.speed;
      robot.y += Math.sin(robot.heading) * robot.speed;
    }

    function followWall(left, front, right) {
      const safe = 20;
      if (front < safe) {
        robot.heading += 0.3;
      } else if (right > safe) {
        robot.heading -= 0.2;
      } else if (left < safe) {
        robot.heading += 0.2;
      }
      robot.x += Math.cos(robot.heading) * robot.speed;
      robot.y += Math.sin(robot.heading) * robot.speed;
    }

    function escapeCorner() {
      robot.x -= Math.cos(robot.heading) * 10;
      robot.y -= Math.sin(robot.heading) * 10;
      robot.heading += (Math.random() > 0.5 ? 1 : -1) * 0.6;
      robot.mode = 'wall-follow';
      robot.stuckFrames = 0;
    }

    function isOnMLine() {
      if (!start || !goal) return false;
      const m = (goal.y - start.y) / (goal.x - start.x);
      const expectedY = start.y + m * (robot.x - start.x);
      return Math.abs(robot.y - expectedY) < Math.max(6, robot.speed*5);
    }

    function angleToGoal() {
      return Math.atan2(goal.y - robot.y, goal.x - robot.x) - robot.heading;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#ef4444';
      for (let obs of obstacles) ctx.fillRect(obs.x, obs.y, obs.w, obs.h);

      if (start) { ctx.fillStyle = 'blue'; ctx.beginPath(); ctx.arc(start.x, start.y, 6, 0, 2*Math.PI); ctx.fill(); }
      if (goal) { ctx.fillStyle = 'green'; ctx.beginPath(); ctx.arc(goal.x, goal.y, 6, 0, 2*Math.PI); ctx.fill(); }

      if (start && goal) {
        ctx.strokeStyle = '#00ffff22';
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(goal.x, goal.y);
        ctx.stroke();
      }

      ctx.fillStyle = 'pink';
      ctx.beginPath();
      ctx.arc(robot.x, robot.y, robot.r, 0, 2 * Math.PI);
      ctx.fill();

      ctx.strokeStyle = 'white';
      ctx.beginPath();
      ctx.moveTo(robot.x, robot.y);
      ctx.lineTo(robot.x + Math.cos(robot.heading) * 15, robot.y + Math.sin(robot.heading) * 15);
      ctx.stroke();
    }

    draw();
  </script>
</body>
</html>
